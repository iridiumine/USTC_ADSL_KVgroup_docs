[TOC]

# Raft阅读记录

[Raft 论文详析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33816607)

[Raft 论文精读笔记｜In Search of an Understandable Consensus Alg orithm (Extended Version) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/514512060)

## 背景

⼀致性算法，或者说**共识算法**，让⼀组机器像⼀个整体⼀样⼯作，即使其中⼀些机器出现故障也能够继续⼯作。

Raft 是⼀种为了管理**复制⽇志**的⼀致性算法。

它将⼀致性**算法分解**成了⼏个关键模块：领导⼈选举、⽇志复制、安全性和角色改变。同时它通过更强的⼀致性来**减少状态机的数量**。

总之，对比传统的一致性算法 Paxos，Raft 更清晰易懂，易于实现。

它有几个独特特性：

- **强领导者**：例如⽇志条⽬只从领导者发送给其他的服务器，简化了对复制⽇志的管理并好理解。
- **领导选举**：用随机计时器来选举领导者，基于心跳机制实现，用于解决冲突。
- **成员关系调整**：使得集群在成员变换的时候依然可以继续⼯作。

## 复制状态机

在CS领域，复制状态机是实现fault-tolerant服务的主要方式，通过复制server并且协调clients对server副本的访问。

分布式系统一般都有很多个客户端和服务组成。每个服务都由一个或多个服务servers构成。当一个server无法应对大流量的客户端访问时，分布式服务会将server复制成多个副本将访问的流量分流给各个副本。但是各个副本会存在数据不一致的情况，使用复制状态机可以解决这个问题。

分布式服务中要求状态机具有确定性：同一状态机的多个副本以“开始”状态开始，并且以相同顺序接收相同输入将到达已生成相同输出的相同状态。这也就是复制状态机的理解。

复制状态机就是用来解决副本的一致性问题的，每个副本都是状态机的实现，而且是确定状态机(Deterministic finite-state machine)。使用状态机来实现每个服务器的副本就保证了对相同的输入，每个副本都会产生一致的输出。并且，将每个客户端的请求汇总成一个序列，每个副本都按照这个序列来执行，这就解决了副本的不一致问题。

**一致性算法基于复制状态机**。

⼤规模的系统中通常都有⼀个集群领导者（Primary，论文中用的 Leader），⼀个独⽴的复制状态机管理领导选举和存储配置信息并且在领导⼈宕机的情况下存活下来。

**复制状态机通常都是基于复制⽇志实现。保证复制⽇志相同就是⼀致性算法的⼯作。**

日志传递 Primary 所有操作记录，让所有 Backup 执行相同的指令序列，达到相同的状态。

<img src="https://pic4.zhimg.com/80/v2-8b70c07436669ef9d2ff1854e0f7cdaf_720w.webp" alt="img" style="zoom:50%;" />

<center style="color:#C0C0C0">图1：复制状态机的架构</center>

实际使用的一致性算法有以下特征：

- **安全性**：非拜占庭错误（出现故障但不会伪造信息）情况下，绝不会返回错误的结果
- **可用性**：只要大多数机器正常就可保证可用
- **不依赖时序保证一致性**
- 一条指令大多数节点可一轮 RPC 完成，**小部分慢节点不影响整体性能**

## Paxos 算法的问题

Paxos ⾸先定义 了⼀个能够达成单⼀决策⼀致的协议，⽐如单条的复制⽇志项。这⼀⼦集叫做**单决策Paxos**。然后通过**组合多个 Paxos 协议的实例来促进⼀系列决策的达成**。

Paxos 是大多数一致性算法的起点，理论上证明可行，但是有两个明显缺点：

1. 特别难以理解。不直观、不透明。
2. 理论可行，实际实现困难，不易于构建实践系统。

Raft 算法就是尝试克服以上缺点，替代 Paxos 的一致性算法。

## 为了可理解性的设计

设计 Raft 的初衷：

- 提供⼀个**完整的实际的系统实现基础**：大大减少开发者的工作
- 任何情况下都是**安全的**
- ⼤多数的情况下都是**可⽤的**
- ⼤部分操作必须是**⾼效的**
- **可理解性**：（最重要、最大挑战）保证普遍⼈都可以容易理解。
- 能够让⼈形成**直观的认识**：使系统的构建者能够在现实中进⾏必然的扩展。

为了可理解性做的工作：

- **问题分解**：尽可能将问题分解成⼏个相对独⽴的、可被解决的、可解释的和可理解的⼦问题。
  Raft 算法被分成领导⼈选举、⽇志复制、安全性和⻆⾊改变⼏个部分。
- **减少状态的数量**来简化需要考虑的状态空间：使得系统更加连贯并且在可能的时候消除不确定性。
  **随机化⽅法**增加了不确定性，但是有利于减少状态空间数量，通过处理所有可能选择时使⽤相似的⽅法。
  使⽤随机化去简化 Raft 中领导⼈选举算法

## Raft 共识算法

Raft 是⼀种⽤来管理复制⽇志的算法。Raft 选举一个 **Leader**，给予管理所有复制日志的权限，由此实现一致性。

Leader 从客户接受指令，写入日志，复制到其他 Backup Server 上，在保证安全性时通知其他 Server 根据日志执行指令更新状态机。

Leader 大大简化了对复制日志的管理。leader 可以自行决定新日志写入位置，数据都从 Leader 流向其他 Server。**当 Leader 宕机，其他 Server 中选举一个新 Leader。**

由此 Raft 将一致性问题分解为**三个子问题**：

- **领导选举**：旧 Leader 宕机选举新 Leader 
- **日志复制**：Leader 接受日志，复制到其他节点并保证一致
- **安全性**：关键在于状态机安全：某一节点应用某个日志条目到状态机，其他节点不能在此条目应用不同指令。此处还涉及一个额外的选举机制上的限制

### State （状态）

**所有服务器上持久存在的：**

（在响应RPCs之前已在稳定的存储上进行更新）

|             |                                                              |
| ----------- | ------------------------------------------------------------ |
| currentTerm | 服务器最后⼀次知道的任期号（初始化为 0，持续递增）           |
| votedFor    | 在当前获得选票的候选⼈的 Id（如果没有则为 null）             |
| log[]       | ⽇志条⽬集；每⼀个条⽬包含⼀个⽤户状态机执⾏的指令，和收到时的任期号 |

**所有服务器上经常变的：**

|             |                                                            |
| ----------- | ---------------------------------------------------------- |
| commitIndex | 已知的最⼤的已经被提交的⽇志条⽬的索引值                   |
| lastApplied | 最后被应⽤到状态机的⽇志条⽬索引值（初始化为 0，持续递增） |

**在领导⼈⾥经常改变的：**

（选举后重新初始化）

|              |                                                              |
| ------------ | ------------------------------------------------------------ |
| nextIndex[]  | 对于每⼀个服务器，需要发送给他的下⼀个⽇志条⽬的索引值（初始化为领导⼈最后索引值加⼀） |
| matchIndex[] | 对于每⼀个服务器，已经复制给他的⽇志的最⾼索引值             |

### AppendEntries RPC（追加待同步⽇志 RPC）

由 Leader 负责调⽤来复制⽇志；也会⽤作心跳

**传入参数：**

|              |                                                              |
| ------------ | ------------------------------------------------------------ |
| term         | 领导⼈的任期号                                               |
| leaderId     | 领导⼈的 Id，以便于跟随者重定向请求                          |
| prevLogIndex | 新的⽇志条⽬紧随之前的索引值                                 |
| prevLogTerm  | prevLogIndex 条⽬的任期号                                    |
| entries[]    | 准备存储的⽇志条⽬（表示⼼跳时为空；⼀次性发送多个是为了提⾼效率） |
| leaderCommit | 领导⼈已经提交的⽇志的索引值                                 |

**返回值：**

|         |                                                             |
| ------- | ----------------------------------------------------------- |
| term    | 当前的任期号，⽤于领导⼈去更新⾃⼰                          |
| success | 跟随者包含了匹配上 prevLogIndex 和 prevLogTerm 的⽇志时为真 |

**接收者实现：**

1. 如果 `term < currentTerm` 就返回 `false` 
2. 如果⽇志在 `prevLogIndex` 位置处的⽇志条⽬的任期号和 `prevLogTerm` 不匹配，则返回 `false`
3. 如果现有的⽇志条⽬和新的产⽣冲突（索引值相同但是任期号不同），删除现有的和之后所有的条目 
4. 如果 `leaderCommit` > `commitIndex` ，令 `commitIndex = min(leaderCommit, 新日志条目索引)`